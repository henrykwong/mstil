#' This function return the quasi density function for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an upper triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom.
#' @param u (Optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (Optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param log.p a logical value. If TRUE, return the probability density function in logarithmic scale. By default FALSE.
#' @return gives a numeric vector of length n.
#' @export
#' @examples # Not run:
#' @examples data(RiverFlow)
#' @examples k <- ncol(RiverFlow)
#' @examples lambda <- diag(k)
#' @examples delta <- rep(0,k)
#' @examples Ainv <- diag(k)
#' @examples nu <- 2
#' @examples dmstil(log(RiverFlow), lambda, delta, Ainv, nu)
dmstil = function( x, lambda, delta, Ainv, nu, u, sample.mc = 10000, log.p = FALSE ){
  if (is.data.frame(x)) x = as.matrix(x)
  if ( missing( u ) ){
    u = mvtnorm::rmvt( sample.mc, delta = rep(0, dim( x )[ 2 ]), sigma = diag(dim( x )[ 2 ]), df = nu )
  }
  z = t( ( t( x ) - delta )  ) %*% t(Ainv)

  Gz = stats::plogis( z %*% lambda, log.p = TRUE)
  Gu = stats::plogis( u %*% lambda, log.p = TRUE )

  res = rowSums( Gz ) + dmvt2( x, delta = delta, Ainv = Ainv, df = nu, log = TRUE ) - log( mean( exp( rowSums( Gu  ) ) ) )

  if ( log.p ) return ( res )
  else return( exp( res ) )
}


#' This function estimate the value of log likelihood function
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an upper triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param u (optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @return a list with components:
#' \item{logL.lower}{the lower bound of the estimated log-likelihood function.}
#' \item{logL}{the estimate of the log-likelihood function.}
#' \item{logL.upper}{the upper bound of the estimated log-likelihood function.}
#' @export
#' @examples data(RiverFlow)
#' @examples k <- ncol(RiverFlow)
#' @examples lambda <- diag(k)
#' @examples delta <- rep(0,k)
#' @examples Ainv <- diag(k)
#' @examples nu <- 2
#' @examples mstil.logL(log(RiverFlow), lambda, delta, Ainv, nu)
mstil.logL = function( x, lambda, delta, Ainv, nu, u, sample.mc = 10000, q = 0.95 ){
  if (is.data.frame(x)) x = as.matrix(x)
  n = nrow(x)
  z = t( ( t( x ) - delta )  ) %*% t(Ainv)

  if ( missing( u ) ){
    u = mvtnorm::rmvt( sample.mc, delta = rep(0, dim( x )[ 2 ]), sigma = diag(dim( x )[ 2 ]), df = nu )
  }

  Gz = stats::plogis( z %*% lambda, log.p = TRUE)
  Gu = stats::plogis( u %*% lambda, log.p = TRUE)

  exp_Gu = exp(rowSums(Gu))
  E_Gu_sd = stats::sd(exp_Gu) / sqrt(nrow(u))
  E_Gu = mean( exp_Gu )
  spread = abs(stats::qnorm((1-q)/2)) * E_Gu_sd

  res = sum(rowSums( Gz ) + dmvt2( x, delta = delta, Ainv = Ainv, df = nu, log = TRUE ))
  return( list( logL.lower = res - n * log(E_Gu + spread), logL = res - n * log(E_Gu), logL.upper = res - n * log(E_Gu - spread)))
}

#' This function finds the penalised quasi likelihood estiamtes for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an upper triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param u (optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param step.size a positive value representing the step size used in fitting nu. By default 0.1.
#' @param dim.rate a non-negative value representing the step size diminishing rate used in fitting nu. By default 0.01.
#' @param iter.sgd a positive integer representing the number of iterations used in fitting nu. By default 100.
#' @param sample.mc a positive integer, representing the number of monte carlo samples used in the quasi log-likelihood function. By default 10000.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the QMLE step. By default 10.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.n a positive integer, the algorithm stops when estimated log-likelihood does not increase in "convergence.n" consecutive iterations. By default 5.
#' @param sample.logL a positive integer, representing the number of monte carlo samples used to estimate the current log-likelihood. By default 1000000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @param lambda.penalty a non-negative value, representing the parameter of the penalty term. By default 0.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{logL.lower}{a numeric vector of the lower bound of the estimated log-likelihood function after each iteration.}
#' \item{logL.upper}{a numeric vector of the upper bound of the estimated log-likelihood function after each iteration.}
#' \item{fun.value}{a numeric vector of the fitted penalised quasi log-likelihood function at each iteration.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples # fit a 2 dimensional mstil distribution 
#' @examples fit.mstil(log(RiverFlow[,1:2]))
fit.mstil = function( x, lambda, delta, Ainv, nu, u, step.size = 0.1, dim.rate = 0.01, iter.sgd = 100, sample.mc = 10000, maxit.bfgs = 10,  maxit = 1000, convergence.n = 5, sample.logL = 1000000, q = 0.025,lambda.penalty = 0, print.progress = TRUE){
  if (is.data.frame(x)) x = as.matrix(x)
  k = dim(x)[2]
  if (missing(lambda)){
    lambda=matrix(stats::runif(k*k, -0.01, 0.01 ),nrow=k)
  }
  if( missing(delta)){
    delta = colMeans(x[sample(nrow(x),round(nrow(x)/10)),])
  }
  if(missing(Ainv)){
    Ainv = solve(t(chol(stats::cov(x[sample(nrow(x),round(nrow(x)/10)),]))))
  }
  if (missing(nu)){
    nu = 10
  }
  res = list()
  res$lambda = lambda
  res$delta = delta
  res$Ainv = Ainv
  res$nu = nu
  start_time = Sys.time()
  lik = sum(dmvt2(x, delta, Ainv, nu, log = TRUE))
  lik_rec = lik
  lik_rec_lower = lik
  lik_rec_upper = lik
  lik_ori = lik
  time_rec = 0
  res_rec = list()
  res_rec[[1]] = res


  for( i in 2 : (maxit + 1)){
    res = fit.mstil.qcmle(x, res$lambda, res$delta, res$Ainv, res$nu, maxit = maxit.bfgs, sample.mc = sample.mc,lambda.penalty = lambda.penalty)
    res$nu = fit.mstil.sgd(x,res$lambda,res$delta,res$Ainv,nu,step.size=step.size/length(x), dim.rate = dim.rate, iter.sgd = iter.sgd, sample.mc = sample.mc)
    nu = res$nu
    lik = mstil.logL(x,res$lambda,res$delta,res$Ainv,res$nu,sample.mc=sample.logL,q=q)
    res_rec[[i]] = res
    lik_rec = c(lik_rec,lik$logL)
    lik_rec_lower = c(lik_rec_lower, lik$logL.lower)
    lik_rec_upper = c(lik_rec_upper, lik$logL.upper)
    lik_ori = c(lik_ori, res$value)
    time_rec = c( time_rec, as.numeric( Sys.time() - start_time, units = 'secs'))
    if (print.progress){
      cat('\r', 'Iterationa : ',i, 'Current Likelihood : ', round(lik_rec[length(lik_rec)]), 'Maximum Likelihood : ', round(max(lik_rec)), '\t')
    }


    if (all(lik_rec[max((i - convergence.n + 1 ),1) : i ] < max(lik_rec)) && i > (convergence.n+1)){
      cat('\n','converged!')
      return(list(logL = lik_rec, par = res_rec, logL.lower = lik_rec_lower, logL.upper = lik_rec_upper,  fun.value = lik_ori, time = time_rec))
      break
    }
  }
  cat('\n','maximum number of iteration reached!')
  return(list(logL = lik_rec, par = res_rec, logL_lower = lik_rec_lower, logL_upper = lik_rec_upper,  fun_value = lik_ori, time = time_rec))
}
