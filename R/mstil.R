#' This function return the quasi density function for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom.
#' @param u (Optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (Optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param log.p a logical value. If TRUE, return the probability density function in logarithmic scale. By default FALSE.
#' @return gives a numeric vector of length n.
#' @export
#' @examples
#' # Not run:
#' # data(RiverFlow)
#' # k <- ncol(RiverFlow)
#' # lambda <- diag(k)
#' # delta <- rep(0,k)
#' # Ainv <- diag(k)
#' # nu <- 2
#' # dmstil(log(RiverFlow), lambda, delta, Ainv, nu)
dmstil <- function(x, lambda, delta, Ainv, nu, u, sample.mc = 10000, log.p = FALSE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  if (missing(u)) {
    u <- mvtnorm::rmvt(sample.mc, delta = rep(0, dim(x)[2]), sigma = diag(dim(x)[2]), df = nu)
  }
  k <- ncol(x)
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")

  z <- t((t(x) - delta)) %*% t(Ainv)

  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  Gu <- stats::plogis(u %*% lambda, log.p = TRUE)

  res <- rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE) - log(mean(exp(rowSums(Gu))))

  if (log.p) {
    return(res)
  } else {
    return(exp(res))
  }
}


#' This function estimate the value of log likelihood function
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param u (optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @return a list with components:
#' \item{logL.lower}{the lower bound of the estimated log-likelihood function.}
#' \item{logL}{the estimate of the log-likelihood function.}
#' \item{logL.upper}{the upper bound of the estimated log-likelihood function.}
#' @export
#' @examples
#' # Not run:
#' # data(RiverFlow)
#' # k <- ncol(RiverFlow)
#' # lambda <- diag(k)
#' # delta <- rep(0,k)
#' # Ainv <- diag(k)
#' # nu <- 2
#' # mstil.logL(log(RiverFlow), lambda, delta, Ainv, nu)
mstil.logL <- function(x, lambda, delta, Ainv, nu, u, sample.mc = 10000, q = 0.95) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- ncol(x)
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")
  if (q >= 1 | q <= 0.5) stop("q must be between 0.5 and 1!")
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  z <- t((t(x) - delta)) %*% t(Ainv)

  if (missing(u)) {
    u <- mvtnorm::rmvt(sample.mc, delta = rep(0, dim(x)[2]), sigma = diag(dim(x)[2]), df = nu)
  }

  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  Gu <- stats::plogis(u %*% lambda, log.p = TRUE)

  exp_Gu <- exp(rowSums(Gu))
  E_Gu_sd <- stats::sd(exp_Gu) / sqrt(nrow(u))
  E_Gu <- mean(exp_Gu)
  spread <- abs(stats::qnorm((1 - q) / 2)) * E_Gu_sd

  res <- sum(rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE))
  return(list(logL.lower = res - n * log(E_Gu + spread), logL = res - n * log(E_Gu), logL.upper = res - n * log(E_Gu - spread)))
}

#' This function finds the penalised quasi likelihood estiamtes for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param step.size a positive value representing the step size used in fitting nu. By default 0.1.
#' @param dim.rate a non-negative value representing the step size diminishing rate used in fitting nu. By default 0.01.
#' @param iter.sgd a positive integer representing the number of iterations used in fitting nu. By default 100.
#' @param tol.sgd a positive value, representing the finite difference tolerance for gradient estimations.
#' @param sample.mc a positive integer, representing the number of monte carlo samples used in the quasi log-likelihood function. By default 10000.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the QMLE step. By default 10.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.n a positive integer, the algorithm stops when estimated log-likelihood does not increase in "convergence.n" consecutive iterations. By default 5.
#' @param sample.logL a positive integer, representing the number of monte carlo samples used to estimate the current log-likelihood. By default 1000000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @param lambda.penalty a non-negative value, representing the parameter of the penalty term. By default 0.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{logL.lower}{a numeric vector of the lower bound of the estimated log-likelihood function after each iteration.}
#' \item{logL.upper}{a numeric vector of the upper bound of the estimated log-likelihood function after each iteration.}
#' \item{fun.value}{a numeric vector of the fitted penalised quasi log-likelihood function at each iteration.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
#' # fit.mstil(log(RiverFlow))
fit.mstil <- function(x, lambda, delta, Ainv, nu, step.size = 0.1, dim.rate = 0.01, iter.sgd = 100, tol.sgd = 1e-5, sample.mc = 10000, maxit.bfgs = 10, maxit = 1000, convergence.n = 5, sample.logL = 1000000, q = 0.95, lambda.penalty = 0, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- dim(x)[2]
  if (missing(lambda)) lambda <- diag(stats::runif(k, -0.01, 0.01))
  if (missing(delta)) delta <- colMeans(x)
  if (missing(Ainv)) {
    Ainv <- solve(t(chol(stats::cov(x))))
    Ainv[upper.tri(Ainv, diag = FALSE)] <- 0
  }
  if (missing(nu)) nu <- 10
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")


  res <- list()
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu

  start_time <- Sys.time()

  lik <- mstil.logL(x, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL, q = q)
  lik_rec <- lik$logL
  lik_rec_lower <- lik$logL.lower
  lik_rec_upper <- lik$logL.upper
  lik_ori <- lik$logL

  time_rec <- 0

  res_rec <- list()
  res_rec[[1]] <- res


  for (i in 2:(maxit + 1)) {
    res <- fit.mstil.qcmle(x, res$lambda, res$delta, res$Ainv, res$nu, maxit = maxit.bfgs, sample.mc = sample.mc, lambda.penalty = lambda.penalty)
    res$nu <- fit.mstil.sgd(x, res$lambda, res$delta, res$Ainv, nu, tol = tol.sgd, step.size = step.size / length(x), dim.rate = dim.rate, iter.sgd = iter.sgd, sample.mc = sample.mc)
    lik <- mstil.logL(x, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL, q = q)
    res_rec[[i]] <- res
    lik_rec <- c(lik_rec, lik$logL)
    lik_rec_lower <- c(lik_rec_lower, lik$logL.lower)
    lik_rec_upper <- c(lik_rec_upper, lik$logL.upper)
    lik_ori <- c(lik_ori, res$value)
    time_rec <- c(time_rec, as.numeric(Sys.time() - start_time, units = "secs"))
    if (print.progress) {
      cat("\r", "Iterationa : ", (i - 1), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    
    if ( i > convergence.n ){
      if ( all( lik_rec[i-convergence.n] > lik_rec[ (i-convergence.n+1) : i ])){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, logL.lower = lik_rec_lower, logL.upper = lik_rec_upper, fun.value = lik_ori, time = time_rec))
        break
      }
    }
  }
  if (print.progress) cat("\n", "maximum number of iteration reached!")
  return(list(logL = lik_rec, par = res_rec, logL_lower = lik_rec_lower, logL_upper = lik_rec_upper, fun_value = lik_ori, time = time_rec))
}




#' This function finds the penalised quasi likelihood estiamtes for finite mixture of mstil via EM.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K a positive integer, number of clusters. 
#' @param omega a positive numeric vector of length K, where sum of the vector equals to 1.
#' @param lambda list of K numeric skewing matrices of size k x p.
#' @param delta list of K numeric vectors of length k, representing the location parameter.
#' @param Ainv list of lower triangular numeric matrices of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu list of positive values representing the degree of freedom.
#' @param step.size a positive value representing the step size used in fitting nu. By default 0.1.
#' @param dim.rate a non-negative value representing the step size diminishing rate used in fitting nu. By default 0.01.
#' @param iter.sgd a positive integer representing the number of iterations used in fitting nu. By default 100.
#' @param tol.sgd a positive value, representing the finite difference tolerance for gradient estimations.
#' @param sample.mc a positive integer, representing the number of monte carlo samples used in the quasi log-likelihood function. By default 10000.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the QMLE step. By default 10.
#' @param maxit.qmle a positive integer, representing the number of iteration within each M-step.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.n a positive integer, the algorithm stops when estimated log-likelihood does not increase in "convergence.n" consecutive iterations. By default 5.
#' @param sample.logL a positive integer, representing the number of monte carlo samples used to estimate the current log-likelihood. By default 1000000.
#' @param lambda.penalty a non-negative value, representing the parameter of the penalty term. By default 0.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.fmmstil <- function(x, K, omega, lambda, delta, Ainv, nu, step.size = 0.01, dim.rate = 0.01, iter.sgd = 100, tol.sgd = 1e-5, sample.mc = 10000, maxit.bfgs = 10, maxit.qmle = 1, maxit = 1000, convergence.n = 5, sample.logL = 1000000, lambda.penalty = 0, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  k <- ncol(x)
  res <- list()

  if (any(missing(omega), missing(lambda), missing(delta), missing(Ainv), missing(nu))) {
    kmeans_cluster <- stats::kmeans(x[sample(n, round(n / 1.5)), ], K)
    omega <- table(kmeans_cluster$cluster) / length(kmeans_cluster$cluster)
    lambda <- list()
    delta <- list()
    Ainv <- list()
    nu <- list()
    for (i in 1:K) {
      first_fitted <- fit.mstil(x[which(kmeans_cluster$cluster == i), ], print.progress = FALSE, maxit = 1, maxit.bfgs = 5)
      mm <- which.max(first_fitted$logL)
      lambda[[i]] <- first_fitted$par[[mm]]$lambda
      delta[[i]] <- first_fitted$par[[mm]]$delta
      Ainv[[i]] <- first_fitted$par[[mm]]$Ainv
      nu[[i]] <- first_fitted$par[[mm]]$nu
    }
  }

  res$omega <- omega
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu
  start_time <- Sys.time()
  lik_rec <- c()
  res_rec <- list()
  time_rec <- c()
  for (i in 1:maxit) {
    w_ <- mstil.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL)
    d <- rowSums(w_)
    logL <- sum(log(d))
    w <- w_ / d
    res$omega <- colSums(w) / n
    lik_rec <- c(lik_rec, logL)
    res_rec[[i]] <- res
    time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

   if ( i > convergence.n ){
     if ( all( lik_rec[i-convergence.n] > lik_rec[ (i-convergence.n+1) : i ])){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, time = time_rec))
        break
     }
   }

    if (print.progress) {
      cat("\r", "Iterationa : ", i, "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    for (j in 1:K) {
      for (jj in 1:maxit.qmle) {
        res1 <- fit.mstil.weighted.qmle(x, w[, j], lambda = res$lambda[[j]], delta = res$delta[[j]], Ainv = res$Ainv[[j]], nu = res$nu[[j]], sample.mc = sample.mc, lambda.penalty = lambda.penalty, maxit = maxit.bfgs)
        res$lambda[[j]] <- res1$lambda
        res$delta[[j]] <- res1$delta
        res$Ainv[[j]] <- res1$Ainv
        res$nu[[j]] <- fit.mstil.weighted.sgd(x, w[, j], res$lambda[[j]], res$delta[[j]], res$Ainv[[j]], res$nu[[j]], step.size = step.size / length(x), dim.rate = dim.rate, iter.sgd = iter.sgd, sample.mc = sample.mc)
      }
    }
  }

  w_ <- mstil.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL)
  d <- rowSums(w_)
  logL <- sum(log(d))
  w <- w_ / d
  res$omega <- colSums(w) / n
  lik_rec <- c(lik_rec, logL)
  res_rec[[length(lik_rec)]] <- res
  time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

  if (print.progress) {
    cat("\r", "Iterationa : ", length(lik_rec), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    cat("\n", "maximum number of iteration reached!")
  }
  return(list(logL = lik_rec, par = res_rec, time = time_rec))
}

#' This function finds the maximum likelihood estiamtes for finite mixture of restricted mstil via EM.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K a positive integer, number of clusters. 
#' @param omega a positive numeric vector of length K, where sum of the vector equals to 1.
#' @param lambda list of K numeric skewing matrices of size k x p.
#' @param delta list of K numeric vectors of length k, representing the location parameter.
#' @param Ainv list of lower triangular numeric matrices of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu list of positive values representing the degree of freedom.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the MLE step. By default 1000.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.tol the maximum tolerance before the algorithm stops.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.fmmstil.r <- function(x, K, omega, lambda, delta, Ainv, nu, maxit.bfgs = 1000, maxit = 1000, convergence.tol = 0.01, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  k <- ncol(x)
  res <- list()

  if (any(missing(omega), missing(lambda), missing(delta), missing(Ainv), missing(nu))) {
    kmeans_cluster <- stats::kmeans(x, K)
    omega <- table(kmeans_cluster$cluster) / length(kmeans_cluster$cluster)
    lambda <- list()
    delta <- list()
    Ainv <- list()
    nu <- list()
    for (i in 1:K) {
      lambda[[i]] <- diag(rep(0, k))
      delta[[i]] <- colMeans(x[which(kmeans_cluster$cluster == i), ])
      Ainv[[i]] <- solve(t(chol(stats::cov(x[which(kmeans_cluster$cluster == i), ]))))*lower.tri(diag(k),diag = TRUE)
      nu[[i]] <- 10
    }
  }

  res$omega <- omega
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu
  start_time <- Sys.time()
  lik_rec <- c()
  res_rec <- list()
  time_rec <- c()
  for (i in 1:maxit) {
    w_ <- mstil.r.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu)
    d <- rowSums(w_)
    logL <- sum(log(d))
    w <- w_ / d
    res$omega <- colSums(w) / n
    lik_rec <- c(lik_rec, logL)
    res_rec[[i]] <- res
    time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))
    if (i > 5){
      if ( lik_rec[i] - lik_rec[i-1] < convergence.tol ){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, time = time_rec))
        break
      }
    }

    if (print.progress) {
      cat("\r", "Iteration : ", i, "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    for (j in 1:K) {
      res1 <- fit.mstil.r.weighted(x, w[, j], lambda = res$lambda[[j]], delta = res$delta[[j]], Ainv = res$Ainv[[j]], nu = res$nu[[j]], maxit = maxit.bfgs)
      res$lambda[[j]] <- res1$lambda
      res$delta[[j]] <- res1$delta
      res$Ainv[[j]] <- res1$Ainv
      res$nu[[j]] <- res1$nu
    }
  }

  w_ <- mstil.r.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu)
  d <- rowSums(w_)
  logL <- sum(log(d))
  w <- w_ / d
  res$omega <- colSums(w) / n
  lik_rec <- c(lik_rec, logL)
  res_rec[[length(lik_rec)]] <- res
  time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

  if (print.progress) {
    cat("\r", "Iterationa : ", length(lik_rec), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    cat("\n", "maximum number of iteration reached!")
  }
  return(list(logL = lik_rec, par = res_rec, time = time_rec))
}



#' This function returns to likelihood function of restricted mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric diagonal skewing matrix of size k x k.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param log.p a logical value. If TRUE, return the probability density function in logarithmic scale. By default FALSE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
dmstil.r <- function(x, lambda, delta, Ainv, nu, log.p = FALSE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  if (any(diag(diag(lambda)) != lambda)) stop("lambda must be a diagonal matrix!")
  k <- ncol(x)
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")

  z <- t((t(x) - delta)) %*% t(Ainv)
  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  res <- rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE) + k * log(2)
  if (log.p) {
    return(res)
  } else {
    return(exp(res))
  }
}


#' This function finds the maximum likelihood estimations for restricted mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric diagonal skewing matrix of size k x k.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.mstil.r <- function(x, lambda, delta, Ainv, nu, maxit = 1000) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- ncol(x)
  n <- nrow(x)

  if (missing(lambda)) lambda <- diag(stats::runif(k, -0.01, 0.01))
  if (missing(delta)) delta <- colMeans(x)
  if (missing(Ainv)) {
    Ainv <- solve(t(chol(stats::cov(x))))
    Ainv[upper.tri(Ainv, diag = FALSE)] <- 0
  }
  if (missing(nu)) nu <- 10
  if (any((lambda*diag(k)) != lambda)) stop("lambda must be a diagonal matrix!")
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")

  lik <- function(param) {
    lambda <- diag(param[1:k])
    delta <- param[1:k + (k)]
    Ainv <- matrix(0, nrow = k, ncol = k)
    Ainv[lower.tri(Ainv, diag = TRUE)] <- param[(k + k + 1):(length(param) - 1)]
    nu <- param[length(param)]
    nu <- max(1, nu)
    res <- sum(dmstil.r(x, lambda, delta, Ainv, nu, log.p = TRUE))
    return(res)
  }

  grad <- function(param) {
    lambda <- diag(param[1:k])
    delta <- param[1:k + (k)]
    Ainv <- matrix(0, nrow = k, ncol = k)
    Ainv[lower.tri(Ainv, diag = TRUE)] <- param[(k + k + 1):(length(param) - 1)]
    nu <- param[length(param)]
    grad <- dmstil.r.grad(x, lambda, delta, Ainv, nu)
    gr <- c(diag(grad$dlambda), grad$dmu, grad$dAinv[lower.tri(diag(k), diag = TRUE)], grad$dnu)
    return(gr)
  }
  param0 <- c(diag(lambda), delta, Ainv[lower.tri(diag(k), diag = TRUE)], nu)
  res <- stats::optim(param0, lik, grad, method = "BFGS", control = c(fnscale = -1, maxit = maxit))
  param1 <- res$par
  lambda1 <- diag(param1[1:k])
  delta1 <- param1[1:k + (k)]
  Ainv1 <- matrix(0, nrow = k, ncol = k)
  Ainv1[lower.tri(Ainv1, diag = TRUE)] <- param1[(k + (k) + 1):(length(param1) - 1)]
  nu1 <- param1[length(param1)]

  return(list(lambda = lambda1, delta = delta1, Ainv = Ainv1, nu = nu1, logL = res$value))
}
