#' This function return the quasi density function for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom.
#' @param u (Optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (Optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param log.p a logical value. If TRUE, return the probability density function in logarithmic scale. By default FALSE.
#' @return gives a numeric vector of length n.
#' @export
#' @examples
#' # Not run:
#' # data(RiverFlow)
#' # k <- ncol(RiverFlow)
#' # lambda <- diag(k)
#' # delta <- rep(0,k)
#' # Ainv <- diag(k)
#' # nu <- 2
#' # dmstil(log(RiverFlow), lambda, delta, Ainv, nu)
dmstil <- function(x, lambda, delta, Ainv, nu, u, sample.mc = 10000, log.p = FALSE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  if (missing(u)) {
    u <- mvtnorm::rmvt(sample.mc, delta = rep(0, dim(x)[2]), sigma = diag(dim(x)[2]), df = nu)
  }
  k <- ncol(x)
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")

  z <- t((t(x) - delta)) %*% t(Ainv)

  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  Gu <- stats::plogis(u %*% lambda, log.p = TRUE)

  res <- rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE) - log(mean(exp(rowSums(Gu))))

  if (log.p) {
    return(res)
  } else {
    return(exp(res))
  }
}


#' This function estimate the value of log likelihood function
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param u (optional) a m x k matrix, representing samples generated by a standard k-dimensional multivariate t distribution with degree of freedom nu.
#' @param sample.mc (optional) a positive integer. If u is not specified, generate "sample.mc" samples from a standard k-dimensional multivariate t distribution with degree of freedom nu. By default 10000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @return a list with components:
#' \item{logL.lower}{the lower bound of the estimated log-likelihood function.}
#' \item{logL}{the estimate of the log-likelihood function.}
#' \item{logL.upper}{the upper bound of the estimated log-likelihood function.}
#' @export
#' @examples
#' # Not run:
#' # data(RiverFlow)
#' # k <- ncol(RiverFlow)
#' # lambda <- diag(k)
#' # delta <- rep(0,k)
#' # Ainv <- diag(k)
#' # nu <- 2
#' # mstil.logL(log(RiverFlow), lambda, delta, Ainv, nu)
mstil.logL <- function(x, lambda, delta, Ainv, nu, u, sample.mc = 10000, q = 0.95) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- ncol(x)
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")
  if (q >= 1 | q <= 0.5) stop("q must be between 0.5 and 1!")
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  z <- t((t(x) - delta)) %*% t(Ainv)

  if (missing(u)) {
    u <- mvtnorm::rmvt(sample.mc, delta = rep(0, dim(x)[2]), sigma = diag(dim(x)[2]), df = nu)
  }

  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  Gu <- stats::plogis(u %*% lambda, log.p = TRUE)

  exp_Gu <- exp(rowSums(Gu))
  E_Gu_sd <- stats::sd(exp_Gu) / sqrt(nrow(u))
  E_Gu <- mean(exp_Gu)
  spread <- abs(stats::qnorm((1 - q) / 2)) * E_Gu_sd

  res <- sum(rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE))
  return(list(logL.lower = res - n * log(E_Gu + spread), logL = res - n * log(E_Gu), logL.upper = res - n * log(E_Gu - spread)))
}

#' This function finds the penalised quasi likelihood estiamtes for mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric skewing matrix of size k x p.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param sgd.step.size a positive value representing the step size used in fitting nu. By default 0.1.
#' @param sgd.dim.rate a non-negative value representing the step size diminishing rate used in fitting nu. By default 0.01.
#' @param sgd.iter a positive integer representing the number of iterations used in fitting nu. By default 100.
#' @param sgd.tol a positive value, representing the finite difference tolerance for gradient estimations.
#' @param sample.mc a positive integer, representing the number of monte carlo samples used in the quasi log-likelihood function. By default 10000.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the QMLE step. By default 10.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.n a positive integer, the algorithm stops when estimated log-likelihood does not increase in "convergence.n" consecutive iterations. By default 5.
#' @param sample.logL a positive integer, representing the number of monte carlo samples used to estimate the current log-likelihood. By default 1000000.
#' @param q a value in range (0.5,1), representing the 2-sided confidence interval percentage. By default 0.95.
#' @param lambda.penalty a non-negative value, representing the parameter of the penalty term. By default 0.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{logL.lower}{a numeric vector of the lower bound of the estimated log-likelihood function after each iteration.}
#' \item{logL.upper}{a numeric vector of the upper bound of the estimated log-likelihood function after each iteration.}
#' \item{fun.value}{a numeric vector of the fitted penalised quasi log-likelihood function at each iteration.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
#' # fit.mstil(log(RiverFlow))
fit.mstil <- function(x, lambda, delta, Ainv, nu, sgd.step.size = 0.1, sgd.dim.rate = 0.01, sgd.iter = 100, sgd.tol = 1e-5, sample.mc = 10000, maxit.bfgs = 10, maxit = 1000, convergence.n = 5, sample.logL = 1000000, q = 0.95, lambda.penalty = 0, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- dim(x)[2]
  if (missing(lambda)) lambda <- 0 * diag(k)
  if (missing(delta)) delta <- colMeans(x)
  if (missing(Ainv)) {
    Ainv <- solve(t(chol(stats::cov(x))))
    Ainv[upper.tri(Ainv, diag = FALSE)] <- 0
  }
  if (missing(nu)) nu <- 10
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")


  res <- list()
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu

  start_time <- Sys.time()

  lik <- mstil.logL(x, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL, q = q)
  lik_rec <- lik$logL
  lik_rec_lower <- lik$logL.lower
  lik_rec_upper <- lik$logL.upper
  lik_ori <- lik$logL

  time_rec <- 0

  res_rec <- list()
  res_rec[[1]] <- res


  for (i in 2:(maxit + 1)) {
    res <- fit.mstil.qcmle(x, res$lambda, res$delta, res$Ainv, res$nu, maxit = maxit.bfgs, sample.mc = sample.mc, lambda.penalty = lambda.penalty)
    res$nu <- fit.mstil.sgd(x, res$lambda, res$delta, res$Ainv, nu, tol = sgd.tol, step.size = sgd.step.size / length(x), dim.rate = sgd.dim.rate, iter = sgd.iter, sample.mc = sample.mc)
    lik <- mstil.logL(x, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL, q = q)
    res_rec[[i]] <- res
    lik_rec <- c(lik_rec, lik$logL)
    lik_rec_lower <- c(lik_rec_lower, lik$logL.lower)
    lik_rec_upper <- c(lik_rec_upper, lik$logL.upper)
    lik_ori <- c(lik_ori, res$value)
    time_rec <- c(time_rec, as.numeric(Sys.time() - start_time, units = "secs"))
    if (print.progress) {
      cat("\r", "Iteration : ", (i - 1), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    
    if ( i > convergence.n ){
      if ( all( lik_rec[i-convergence.n] > lik_rec[ (i-convergence.n+1) : i ])){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, logL.lower = lik_rec_lower, logL.upper = lik_rec_upper, fun.value = lik_ori, time = time_rec))
        break
      }
    }
  }
  if (print.progress) cat("\n", "maximum number of iteration reached!")
  return(list(logL = lik_rec, par = res_rec, logL_lower = lik_rec_lower, logL_upper = lik_rec_upper, fun_value = lik_ori, time = time_rec))
}




#' This function finds the penalised quasi likelihood estiamtes for finite mixture of mstil via EM.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K a positive integer, number of clusters. 
#' @param omega a positive numeric vector of length K, where sum of the vector equals to 1.
#' @param lambda list of K numeric skewing matrices of size k x p.
#' @param delta list of K numeric vectors of length k, representing the location parameter.
#' @param Ainv list of lower triangular numeric matrices of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu list of positive values representing the degree of freedom.
#' @param init.cluster initial cluster to help set initial parameters
#' @param init.method method to find initial parameters. 
#' @param sgd.step.size a positive value representing the step size used in fitting nu. By default 0.1.
#' @param sgd.dim.rate a non-negative value representing the step size diminishing rate used in fitting nu. By default 0.01.
#' @param sgd.iter a positive integer representing the number of iterations used in fitting nu. By default 100.
#' @param sgd.tol a positive value, representing the finite difference tolerance for gradient estimations.
#' @param sample.mc a positive integer, representing the number of monte carlo samples used in the quasi log-likelihood function. By default 10000.
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the QMLE step. By default 10.
#' @param maxit.qmle a positive integer, representing the number of iteration within each M-step.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.n a positive integer, the algorithm stops when estimated log-likelihood does not increase in "convergence.n" consecutive iterations. By default 5.
#' @param sample.logL a positive integer, representing the number of monte carlo samples used to estimate the current log-likelihood. By default 1000000.
#' @param lambda.penalty a non-negative value, representing the parameter of the penalty term. By default 0.
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.fmmstil <- function(x, K, omega, lambda, delta, Ainv, nu, init.cluster, init.method, sgd.step.size = 0.01, sgd.dim.rate = 0.01, sgd.iter = 100, sgd.tol = 1e-5, sample.mc = 10000, maxit.bfgs = 10, maxit.qmle = 1, maxit = 1000, convergence.n = 5, sample.logL = 1000000, lambda.penalty = 0, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  k <- ncol(x)
  res <- list()
  if (any(missing(omega), missing(lambda), missing(delta), missing(Ainv), missing(nu))) {
    if (missing(init.method)) init.method = fit.mstil.r
    lambda <- list()
    delta <- list()
    Ainv <- list()
    nu <- list()
    if (missing(init.cluster)) init.cluster <- stats::kmeans(x, K)$cluster
    omega <- table(init.cluster) / n
    for (i in 1:K){
      fit.temp <- init.method(x[which(init.cluster == unique(init.cluster)[i]), ])
      lambda[[i]] <- fit.temp$lambda
      delta[[i]] <- fit.temp$delta
      Ainv[[i]] <- fit.temp$Ainv
      nu[[i]] <- fit.temp$nu
    }
  }

  res$omega <- omega
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu
  start_time <- Sys.time()
  lik_rec <- c()
  res_rec <- list()
  time_rec <- c()
  for (i in 1:maxit) {
    w_ <- mstil.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL)
    d <- rowSums(w_)
    logL <- sum(log(d))
    w <- w_ / d
    res$omega <- colSums(w) / n
    lik_rec <- c(lik_rec, logL)
    res_rec[[i]] <- res
    time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

   if ( i > convergence.n ){
     if ( all( lik_rec[i-convergence.n] > lik_rec[ (i-convergence.n+1) : i ])){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, time = time_rec))
        break
     }
   }

    if (print.progress) {
      cat("\r", "Iteration : ", i, "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    for (j in 1:K) {
      for (jj in 1:maxit.qmle) {
        res1 <- fit.mstil.weighted.qmle(x, w[, j], lambda = res$lambda[[j]], delta = res$delta[[j]], Ainv = res$Ainv[[j]], nu = res$nu[[j]], sample.mc = sample.mc, lambda.penalty = lambda.penalty, maxit = maxit.bfgs)
        res$lambda[[j]] <- res1$lambda
        res$delta[[j]] <- res1$delta
        res$Ainv[[j]] <- res1$Ainv
        res$nu[[j]] <- fit.mstil.weighted.sgd(x, w[, j], res$lambda[[j]], res$delta[[j]], res$Ainv[[j]], res$nu[[j]], step.size = sgd.step.size / length(x), dim.rate = sgd.dim.rate, iter = sgd.iter, tol = sgd.tol, sample.mc = sample.mc)
      }
    }
  }

  w_ <- mstil.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu, sample.mc = sample.logL)
  d <- rowSums(w_)
  logL <- sum(log(d))
  w <- w_ / d
  res$omega <- colSums(w) / n
  lik_rec <- c(lik_rec, logL)
  res_rec[[length(lik_rec)]] <- res
  time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

  if (print.progress) {
    cat("\r", "Iteration : ", length(lik_rec), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    cat("\n", "maximum number of iteration reached!")
  }
  return(list(logL = lik_rec, par = res_rec, time = time_rec))
}

#' This function finds the maximum likelihood estiamtes for finite mixture of restricted mstil via EM.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K a positive integer, number of clusters. 
#' @param omega a positive numeric vector of length K, where sum of the vector equals to 1.
#' @param lambda list of K numeric skewing matrices of size k x p.
#' @param delta list of K numeric vectors of length k, representing the location parameter.
#' @param Ainv list of lower triangular numeric matrices of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu list of positive values representing the degree of freedom.
#' @param init.cluster initial cluster to help set initial parameters
#' @param init.method method to find initial parameters. 
#' @param maxit.bfgs a positive integer, representing the maximum number of iterations used in the MLE step. By default 1000.
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param convergence.tol the maximum tolerance before the algorithm stops.
#' @param lambda.penalty L1 penalty coefficient for lambda
#' @param print.progress a logical value. If TRUE, progress of the algorithm will be printed in console. By default TRUE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.fmmstil.r <- function(x, K, omega, lambda, delta, Ainv, nu, init.cluster, init.method, maxit.bfgs = 1000, maxit = 1000, convergence.tol = 0.01, lambda.penalty = 0, print.progress = TRUE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  n <- nrow(x)
  k <- ncol(x)
  res <- list()

  if (any(missing(omega), missing(lambda), missing(delta), missing(Ainv), missing(nu))) {
    if (missing(init.method)) init.method = fit.mstil.r
    lambda <- list()
    delta <- list()
    Ainv <- list()
    nu <- list()
    if (missing(init.cluster)) init.cluster <- stats::kmeans(x, K)$cluster
    omega <- table(init.cluster) / n
     for (i in 1:K){
        fit.temp <- init.method(x[which(init.cluster == unique(init.cluster)[i]), ])
        lambda[[i]] <- fit.temp$lambda
        delta[[i]] <- fit.temp$delta
        Ainv[[i]] <- fit.temp$Ainv
        nu[[i]] <- fit.temp$nu
     }
  }
    
    

  res$omega <- omega
  res$lambda <- lambda
  res$delta <- delta
  res$Ainv <- Ainv
  res$nu <- nu
  start_time <- Sys.time()
  lik_rec <- c()
  res_rec <- list()
  time_rec <- c()
  for (i in 1:maxit) {
    w_ <- mstil.r.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu)
    d <- rowSums(w_)
    logL <- sum(log(d))
    w <- w_ / d
    res$omega <- colSums(w) / n
    lik_rec <- c(lik_rec, logL)
    res_rec[[i]] <- res
    time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))
    if (i > 5){
      if ( lik_rec[i] - lik_rec[i-1] < convergence.tol ){
        if (print.progress) cat("\n", "converged!")
        return(list(logL = lik_rec, par = res_rec, time = time_rec))
        break
      }
    }

    if (print.progress) {
      cat("\r", "Iteration : ", i, "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    }
    for (j in 1:K) {
      res1 <- fit.mstil.r.weighted(x, w[, j], lambda = res$lambda[[j]], delta = res$delta[[j]], Ainv = res$Ainv[[j]], nu = res$nu[[j]], maxit = maxit.bfgs, lambda.penalty = lambda.penalty)
      res$lambda[[j]] <- res1$lambda
      res$delta[[j]] <- res1$delta
      res$Ainv[[j]] <- res1$Ainv
      res$nu[[j]] <- res1$nu
    }
  }

  w_ <- mstil.r.weight(x, res$omega, res$lambda, res$delta, res$Ainv, res$nu)
  d <- rowSums(w_)
  logL <- sum(log(d))
  w <- w_ / d
  res$omega <- colSums(w) / n
  lik_rec <- c(lik_rec, logL)
  res_rec[[length(lik_rec)]] <- res
  time_rec <- c(time_rec, difftime(Sys.time(), start_time, units = "secs"))

  if (print.progress) {
    cat("\r", "Iteration : ", length(lik_rec), "Current Likelihood : ", round(lik_rec[length(lik_rec)]), "Maximum Likelihood : ", round(max(lik_rec)), "\t")
    cat("\n", "maximum number of iteration reached!")
  }
  return(list(logL = lik_rec, par = res_rec, time = time_rec))
}



#' This function returns to likelihood function of restricted mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric diagonal skewing matrix of size k x k.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param log.p a logical value. If TRUE, return the probability density function in logarithmic scale. By default FALSE.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
dmstil.r <- function(x, lambda, delta, Ainv, nu, log.p = FALSE) {
  if (is.data.frame(x)) x <- as.matrix(x)
  if (any(diag(diag(lambda)) != lambda)){
    warning("lambda must be a diagonal matrix!")
    return(rep(NaN, nrow(x)))
  }
  k <- ncol(x)
  if (nrow(lambda) != k){
    warning("number of rows of lambda is not equal to dimension of x!")
    return(rep(NaN, nrow(x)))
  }
  if (length(delta) != k){
    warning("length of delta is not equal to dimension of x!")
    return(rep(NaN, nrow(x)))
  }
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)){
    warning("Ainv is of wrong size or is not an lower triangular matrix!")
    return(rep(NaN, nrow(x)))
  }
  if (nu < 0){
    warning('nu is negative!')
    return(rep(NaN, nrow(x)))
  }

  z <- t((t(x) - delta)) %*% t(Ainv)
  Gz <- stats::plogis(z %*% lambda, log.p = TRUE)
  res <- rowSums(Gz) + dmvt2(x, delta = delta, Ainv = Ainv, df = nu, log = TRUE) + k * log(2)
  if (log.p) {
    return(res)
  } else {
    return(exp(res))
  }
}


#' This function finds the maximum likelihood estimations for restricted mstil.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param lambda a numeric diagonal skewing matrix of size k x k.
#' @param delta a numeric vector of length k, representing the location parameter.
#' @param Ainv an lower triangular numeric matrix of size k x k, where t(Ainv) "times" Ainv representing the inverse of the scale parameter.
#' @param nu a positive value representing the degree of freedom/
#' @param maxit a positive integer, representing the maximum number of iterations. By default 1000.
#' @param lambda.penalty L1 penalty coefficient for lambda.
#' @return a list with components:
#' \item{logL}{a vector of the estimated log-likelihood function after each itereation.}
#' \item{par}{a list of list of fitted parameters after each iteration. Within each list, "lambda" is the fitted skewing matrix, "delta" is the location parameter, "Ainv" is the reparameterised scale parameter, "nu" is the degree of freedom.}
#' \item{time}{a non-negative numeric vector, records the time elapsed after each iteration.}
#' @export
#' @examples
#' # Not run:
fit.mstil.r <- function(x, lambda, delta, Ainv, nu, maxit = 1000, lambda.penalty = 0) {
  if (is.data.frame(x)) x <- as.matrix(x)
  k <- ncol(x)
  n <- nrow(x)
  
  if (missing(lambda)) lambda <- 0 * diag(k)
  if (missing(delta)) delta <- colMeans(x)
  if (missing(Ainv)) {
    Ainv <- solve(t(chol(stats::cov(x))))
    Ainv[upper.tri(Ainv, diag = FALSE)] <- 0
  }
  if (missing(nu)) nu <- 10
  if (any((lambda*diag(k)) != lambda)) stop("lambda must be a diagonal matrix!")
  if (nrow(lambda) != k) stop("number of rows of lambda is not equal to dimension of x!")
  if (length(delta) != k) stop("length of delta is not equal to dimension of x!")
  if (ncol(Ainv) != nrow(Ainv) | length(Ainv) != k^2 | any(Ainv[upper.tri(Ainv)] != 0)) stop("Ainv is of wrong size or is not an lower triangular matrix!")
  if (nu < 0) stop("nu must be positive!")

  lik <- function(param) {
    lambda <- diag(param[1:k])
    delta <- param[1:k + (k)]
    Ainv <- matrix(0, nrow = k, ncol = k)
    Ainv[lower.tri(Ainv, diag = TRUE)] <- param[(k + k + 1):(length(param) - 1)]
    lnu <- param[length(param)]
    nu <- exp(lnu)
    res <- sum(dmstil.r(x, lambda, delta, Ainv, nu, log.p = TRUE)) - lambda.penalty * sum(abs(lambda))
    return(res)
  }
  grad <- function(param) {
    lambda <- diag(param[1:k])
    delta <- param[1:k + (k)]
    Ainv <- matrix(0, nrow = k, ncol = k)
    Ainv[lower.tri(Ainv, diag = TRUE)] <- param[(k + k + 1):(length(param) - 1)]
    lnu <- param[length(param)]
    nu <- exp(lnu)
    grad <- dmstil.r.grad(x, lambda, delta, Ainv, nu)
    grad$dlambda <- grad$dlambda - lambda.penalty * sign(lambda)
    gr <- c(diag(grad$dlambda), grad$dmu, grad$dAinv[lower.tri(diag(k), diag = TRUE)], grad$dlnu)

    return(gr)
  }
  param0 <- c(diag(lambda), delta, Ainv[lower.tri(diag(k), diag = TRUE)], log(nu))
  
  
  res <- stats::optim(param0, lik, grad, method = 'BFGS', control = c(fnscale = -1, maxit = maxit))
  param1 <- res$par
  lambda1 <- diag(param1[1:k])
  delta1 <- param1[1:k + (k)]
  Ainv1 <- matrix(0, nrow = k, ncol = k)
  Ainv1[lower.tri(Ainv1, diag = TRUE)] <- param1[(k + (k) + 1):(length(param1) - 1)]
  lnu1 <- param1[length(param1)]
  nu1 <- exp(lnu1)
  return(list(lambda = lambda1, delta = delta1, Ainv = Ainv1, nu = nu1, logL = res$value))
}

#' Clustering using mstil given a fixed number of clusters.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K positive integer, number of cluster.
#' @param nstart a positive integer, number of starting points to be evaluated. 
#' @param init.cluster.method a function of x, K seperate x into initial clusters. 
#' @param init.method a functino of x, return initial parameters. 
#' @param print.progress show progress on console. 
#' @param ... additional parameters 
#' @return a list with components:
#' \item{Restricted}{a list containing details of the best fitted mstil.r.}
#' \item{Unrestricted}{a list containing details of the best fitted mstil.}
#' \item{record}{a list containing all fitted mstil.r.}
#' @export
#' @examples
#' # Not run:
cluster.fmmstil.K = function(x, K, nstart, init.cluster.method, init.method, print.progress = TRUE, ...){
  
  if (missing(init.cluster.method)) init.cluster.method = default.init.cluster
  if (missing(init.method)) init.method = default.init.method
  
  mstil.r.record = list()
  
  k = ncol(x)
  ICL.max = -Inf
  n = nstart
  for (i in 1:n){
    
    if(print.progress) cat('\n','MSTIL.R','\t', 'K : ', K, '\t', 'Trial : ', i, ' of ', n)
    
    init.cluster = init.cluster.method(x, K)
    
    res1 = tryCatch(fit.fmmstil.r(x, K, init.cluster = init.cluster, init.method = init.method, print.progress = FALSE, ...),
                    error = function(e) NA,
                    warning = function(w) NA)
    if (is.list(res1)){
      par = res1$par[[which.max(res1$logL)]]
      classify1 = mstil.r.weight(x, par$omega, par$lambda, par$delta, par$Ainv, par$nu)
      guess1 = apply(classify1, 1, which.max)
      ICL = ICL.fun(classify1, K, k + k + 1 + k * (k + 1) / 2, nrow(x))
      res1$ICL <- ICL
      res1$clust = guess1
      if (ICL > ICL.max){
        res1.true <- res1
        ICL.max <- ICL
        guess1.true <- guess1
      }
      if (print.progress) cat('\t', 'Max ICL : ', (round(ICL.max,2)), '\t', 'Current ICL : ', (round(ICL,2)))
    }
    mstil.r.record[[i]] <- res1
  }
  
  
  if (print.progress) cat('\n','MSTIL  ','\t', 'K : ', K, '\t', 'Trial : ', 1, ' of ', 1)
  
  par = res1.true$par[[which.max(res1.true$logL)]]
  res2.true = tryCatch(fit.fmmstil(x, K, omega = par$omega, lambda = par$lambda, delta = par$delta, Ainv = par$Ainv, nu = par$nu, print.progress = FALSE, ...),
                       error = function(e) res1.true,
                       warning = function(w) res1.true)

  par = res2.true$par[[which.max(res2.true$logL)]]
  classify2 = mstil.weight(x, par$omega, par$lambda, par$delta, par$Ainv, par$nu)
  guess2 = apply(classify2, 1, which.max)
  ICL = ICL.fun(classify2, K, k + 1 + k * (k + 1), nrow(x))
  res2.true$ICL <- ICL
  res2.true$clust <- guess2
  if (print.progress) cat('\t', 'Max ICL : ', (round(ICL.max,2)), '\t', 'Current ICL : ', (round(ICL,2)))

  return(list(Restricted = res1.true, Unrestricted = res2.true, record = mstil.r.record))
}


#' Clustering using mstil given a fixed number of clusters.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param nstart.fun a function that returns nstart given K. 
#' @param init.cluster.method a function of x, K seperate x into initial clusters. 
#' @param init.method a functino of x, return initial parameters. 
#' @param print.progress show progress on console. 
#' @param ... additional parameters 
#' @return a list with components:
#' \item{Res}{a list containing details of the best fitted distribution}
#' \item{Unrestricted}{a list containing details of the best fitted mstil.}
#' \item{record}{a list containing all fitted mstil.r for each K.}
#' @export
#' @examples
#' # Not run:
cluster.fmmstil = function(x, nstart.fun, init.cluster.method, init.method, print.progress = TRUE, ...){
  
  if (missing(nstart.fun)) nstart.fun = function(K) 2^K
  if (missing(init.cluster.method)) init.cluster.method = default.init.cluster
  if (missing(init.method)) init.method = default.init.method
  
  all.record <- list()
  t.start = Sys.time()
  K = 1
  ICL.max = -Inf
  while (TRUE){
    res = cluster.fmmstil.K(x, K, nstart.fun(K), init.cluster.method, init.method, print.progress = print.progress, ...)
    if(print.progress) cat('\n')
    all.record[[K]] <- res$record
    if (ICL.max >= max(res$Restricted$ICL,res$Unrestricted$ICL)){
      res.true$time = difftime(Sys.time(),t.start, units = 'secs')
      return(list(res = res.true, record = all.record))
    } else if (res$Restricted$ICL > res$Unrestricted$ICL){
      res.true = res$Restricted
      ICL.max = res$Restricted$ICL
      K = K + 1
    } else{
      res.true <- res$Unrestricted
      ICL.max <- res$Unrestricted$ICL
      K = K + 1
    }
  }
}


#' Clustering using mstil given a fixed number of clusters in parallel.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param K positive integer, number of cluster.
#' @param ncore a positive integer, number of core to be used
#' @param nstart a positive integer, number of starting points to be evaluated. 
#' @param init.cluster.method a function of x, K seperate x into initial clusters. 
#' @param init.method a functino of x, return initial parameters. 
#' @param print.progress show progress on console. 
#' @param ... additional parameters 
#' @return a list with components:
#' \item{Restricted}{a list containing details of the best fitted mstil.r.}
#' \item{Unrestricted}{a list containing details of the best fitted mstil.}
#' \item{record}{a list containing all fitted mstil.r.}
#' @export
#' @examples
#' # Not run:
cluster.fmmstil.K.parallel = function(x, K, ncore, nstart, init.cluster.method, init.method, print.progress = TRUE, ...){
  if (ncore > parallel::detectCores()){
    warning('Not enough available core')
    ncore <- parallel::detectCores()
  }
  
  if (missing(init.cluster.method)) init.cluster.method = default.init.cluster
  if (missing(init.method)) init.method = default.init.method
  
  k = ncol(x)
  if(print.progress) cat('\n','MSTIL.R','\t', 'K : ', K, '\t', 'Number of Trials : ', ncore)
  
  seed = sample(1000000000, nstart)
  res = parallel::mclapply(seed, cluster.mstil.r.1, x = x, K = K, init.cluster.method = init.cluster.method, init.method = init.method, ...)
  
  ICL.all = c()
  for (i in 1:nstart) ICL.all = c(ICL.all, res[[i]]$ICL)
  res1.true <- res[[which.max(ICL.all)]]
  
  par = res1.true$par[[which.max(res1.true$logL)]]
  
  if (print.progress) cat('\t', 'Max ICL : ', (round(max(ICL.all),2)) )
  
  
  if (print.progress) cat('\n','MSTIL  ','\t', 'K : ', K, '\t')
  res2.true = tryCatch(fit.fmmstil(x, K, omega = par$omega, lambda = par$lambda, delta = par$delta, Ainv = par$Ainv, nu = par$nu, print.progress = FALSE, ...),
                       error = function(e) res1.true,
                       warning = function(w) res1.true)
  
  par = res2.true$par[[which.max(res2.true$logL)]]
  classify2 = mstil.weight(x, par$omega, par$lambda, par$delta, par$Ainv, par$nu)
  guess2 = apply(classify2, 1, which.max)
  ICL = ICL.fun(classify2, K, k + 1 + k * (k + 1), nrow(x))
  res2.true$ICL <- ICL
  res2.true$clust <- guess2
  if (print.progress) cat('\t', 'Max ICL : ', (round(max(ICL.all, ICL),2)) )
  return(list(Restricted = res1.true, Unrestricted = res2.true, record = res))
  
}


#' Clustering using mstil given a fixed number of clusters.
#' @param x a n x k matrix, representing n k-variate samples.
#' @param ncore a positive integer, number of core to be used
#' @param nstart.fun a function that returns nstart given K. 
#' @param init.cluster.method a function of x, K seperate x into initial clusters. 
#' @param init.method a functino of x, return initial parameters. 
#' @param print.progress show progress on console. 
#' @param ... additional parameters 
#' @return a list with components:
#' \item{Res}{a list containing details of the best fitted distribution}
#' \item{Unrestricted}{a list containing details of the best fitted mstil.}
#' \item{record}{a list containing all fitted mstil.r for each K.}
#' @export
#' @examples
#' # Not run:
cluster.fmmstil.parallel = function(x, ncore, nstart.fun, init.cluster.method, init.method, print.progress = TRUE, ...){
  if (missing(nstart.fun)) nstart.fun = function(K) 2^K 
  if (missing(init.cluster.method)) init.cluster.method = default.init.cluster
  if (missing(init.method)) init.method = default.init.method
  
  if (ncore > parallel::detectCores()){
    warning('Not enough available core')
    ncore <- parallel::detectCores()
  }
  
  
  all.record <- list()
  t.start = Sys.time()
  K = 1
  ICL.max = -Inf
  while (TRUE){
    res = cluster.fmmstil.K.parallel(x, K, ncore, nstart.fun(K), init.cluster.method, init.method, print.progress = print.progress, ...)
    if(print.progress) cat('\n')
    all.record[[K]] <- res$record
    if (ICL.max >= max(res$Restricted$ICL,res$Unrestricted$ICL)){
      res.true$time = difftime(Sys.time(),t.start, units = 'secs')
      return(list(res = res.true, record = all.record))
    } else if (res$Restricted$ICL > res$Unrestricted$ICL){
      res.true = res$Restricted
      ICL.max = res$Restricted$ICL
      K = K + 1
    } else{
      res.true <- res$Unrestricted
      ICL.max <- res$Unrestricted$ICL
      K = K + 1
    }
  }
}
